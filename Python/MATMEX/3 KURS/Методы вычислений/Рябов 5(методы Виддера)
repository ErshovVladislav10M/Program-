# Ершов 343 вычи
# вариант 39


import numpy
import cmath
import math
import matplotlib.pyplot as plt


# Функция F(p)
def F(p):
    return (p ** (1/2) - p ** (1/3)) / (p + 2)


# Функция fi(p)
def fi(p):
    return p * F(p)


# Функция G(z, t) (t > 0)
def G(z, t):
    return F((1 - z)/ t) / t


# Функция e_m(x)
def e_m(m, x):
    return cmath.exp(2 * cmath.pi * x * 1j / m)


# Вычисление r от параметра n
def comp_r(n):
    max = 100
    a = 0.0
    b = 1.0
    for i in range(100):
        c = (a + b) / 2
        if (c + 0.001) ** n - (c + 0.001) ** (n + 1) > (c - 0.001) ** n - (c - 0.001) ** (n + 1):
            a = c
        else:
            b = c
    return c


# Вычисление m от второго слагаемого
def comp_m(n, e):
    r = comp_r(n)
    M = 1
    m = 1
    while M * r ** m / (1 - r ** m) > e / ((1 - r) * r ** n):
        m += 1
    return m


# Функция W_n_m(f, t)
def W_n_m(m, n, r, t):
    sum = 0
    for j in range(1, m):
        sum += (r * e_m(m, j)) ** (-n) * fi(n * (1 - r * e_m(m, j)) / t) / (1 - r * e_m(m, j))
    return sum / m


# Вычисление в точках (Метод Виддера W_n_m(f, t))
def solut_1(n, e, t):
    r = comp_r(n)
    m = comp_m(n, e)
    return W_n_m(m, n, r, t)


# Вычисление всех d_j
def comp_d_j(k):
    d_j = [2 * j for j in range(1, k + 1)]
    return d_j


# Вычисление всех c_k_j
def comp_c_k_j(n, k):
    d_j = comp_d_j(k)
    c_k_j = []
    for j in range(1, k + 1):
        ans = 1
        for i in range(1, n + 1):
            if i != j:
                ans *= d_j[j - 1] / (d_j[j - 1] - d_j[i - 1])
        c_k_j.append(ans)
    return c_k_j


# Вычисление в точках (ускоренный Виддер W_n(k, f, t))
def solut_2(n, k, e, t):
    d_j = comp_d_j(k)
    c_k_j = comp_c_k_j(n, k)
    ans = 0
    for j in range(1, k + 1):
        r = comp_r(n * d_j[j - 1])
        m = comp_m(n * d_j[j - 1], e)
        ans += c_k_j[j - 1] * W_n_m(m, n * d_j[j - 1], r, t)
    return ans


# Разложение F(p) в ряд (n - количество элементов в ряде
def row_F(n, p):
    ans = 0
    for i in range(n):
        ans += (-1) ** i * (2 / p) ** i
    return ans * (p ** (1 / 2) - p ** (1 / 3)) / p

def main():

    print('Обращение интегрального преобразования Лапласа')
    print('Ершов Владислав Евгеньевич группа 343')
    print('Вариант 39')

    print('\nУсловие:')
    print('F(p) = (p^(1/2) - p^(1/3)) / (p + 2)')

    # print('Введите параметр n = ')
    # n = int(input())
    n = 801
    # print('Введите погрешность e = ')
    # e = float(input())
    e = 1e-12

    print('\nМетод Виддера')
    print('Погрешность e = ' + str(e))
    print('n\tW_n_m(21.5)')
    for i in range(11):
        print(str(i + n) + '\t' + str(59 * solut_1(i + n, e, 21.5).real))

    print('\nМетод Виддера с ускоренеим сходимости')
    # print('Введите параметр k = ')
    # k = int(input())
    k = 61
    # print('Введите параметр n = ')
    # n = int(input())
    n = 1
    print('k\tW_n_k(21.5), n = ' + str(n))
    for i in range(11):
        print(str(i + k) + '\t' + str(solut_2(n, i + k, e, 21.5).real))

    print('\nОригинал в виде ряда')
    print('n - количество элементов в ряде')
    # print('Введите параметр n = ')
    # n = int(input())
    n = 1
    print('n\trow_F(21.5)')
    for i in range(11):
        print(str(i + n) + '\t' + str(row_F(i + n, 21.5)))


if __name__ == '__main__':
    main()
